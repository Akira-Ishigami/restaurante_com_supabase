import { supabase } from '../lib/supabase';
import { isDemoMode, mockApiDelay } from '../lib/supabase';
import { Database } from '../lib/database.types';
import { demoRestaurant } from '../utils/demo-data';

type Order = Database['public']['Tables']['orders']['Row'];
type OrderInsert = Database['public']['Tables']['orders']['Insert'];
type OrderItem = Database['public']['Tables']['order_items']['Row'];
type OrderItemInsert = Database['public']['Tables']['order_items']['Insert'];

export interface CreatePublicOrderData {
  restaurantId: string;
  customer: {
    name: string;
    phone: string;
    email?: string;
    address?: string;
  };
  items: {
    menuItemId: string;
    quantity: number;
    unitPrice: number;
    specialInstructions?: string;
  }[];
  paymentMethod: 'pix' | 'card' | 'money';
  deliveryAddress?: string;
  customerNotes?: string;
  subtotal: number;
  deliveryFee?: number;
  totalAmount: number;
}

export interface PublicOrderWithItems extends Order {
  order_items: OrderItem[];
  customer?: {
    name: string;
    phone: string;
    email?: string;
  };
}

export class PublicOrderService {
  // Create order from public interface (no authentication required)
  static async createPublicOrder(orderData: CreatePublicOrderData): Promise<PublicOrderWithItems> {
    // Check if we're in demo mode or using demo restaurant ID
    const isDemo = isDemoMode() || orderData.restaurantId === demoRestaurant.id || orderData.restaurantId === 'demo-restaurant-1';
    
    if (isDemo) {
      await mockApiDelay();
      
      const mockOrder: PublicOrderWithItems = {
        id: `demo-order-${Date.now()}`,
        restaurant_id: demoRestaurant.id!,
        customer_id: `demo-customer-${Date.now()}`,
        order_number: `PED-${new Date().toISOString().slice(0, 10).replace(/-/g, '')}-${Math.floor(Math.random() * 9999).toString().padStart(4, '0')}`,
        payment_method: orderData.paymentMethod,
        subtotal: orderData.subtotal,
        delivery_fee: orderData.deliveryFee || 0,
        total_amount: orderData.totalAmount,
        delivery_address: orderData.deliveryAddress || null,
        customer_notes: orderData.customerNotes || null,
        status: 'pending',
        payment_status: 'pending',
        tax_amount: 0,
        estimated_delivery_time: null,
        delivered_at: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        order_items: orderData.items.map((item, index) => ({
          id: `demo-item-${index}`,
          order_id: `demo-order-${Date.now()}`,
          menu_item_id: item.menuItemId,
          quantity: item.quantity,
          unit_price: item.unitPrice,
          total_price: item.unitPrice * item.quantity,
          special_instructions: item.specialInstructions || null,
          created_at: new Date().toISOString()
        })),
        customer: {
          name: orderData.customer.name,
          phone: orderData.customer.phone,
          email: orderData.customer.email
        }
      };
      
      return mockOrder;
    }

    try {
      // First, find or create customer
      let customer;
      
      // Try to find existing customer by phone
      const { data: existingCustomer } = await supabase
        .from('customers')
        .select('*')
        .eq('restaurant_id', orderData.restaurantId)
        .eq('phone', orderData.customer.phone)
        .single();
      
      if (existingCustomer) {
        customer = existingCustomer;
      } else {
        // Create new customer
        const { data: newCustomer, error: customerError } = await supabase
          .from('customers')
          .insert({
            restaurant_id: orderData.restaurantId,
            name: orderData.customer.name,
            phone: orderData.customer.phone,
            email: orderData.customer.email,
            address: orderData.customer.address
          })
          .select()
          .single();
        
        if (customerError) throw customerError;
        customer = newCustomer;
      }

      // Create order
      const orderInsert: OrderInsert = {
        restaurant_id: orderData.restaurantId,
        customer_id: customer.id,
        order_number: '', // Will be auto-generated by trigger
        payment_method: orderData.paymentMethod,
        subtotal: orderData.subtotal,
        delivery_fee: orderData.deliveryFee || 0,
        total_amount: orderData.totalAmount,
        delivery_address: orderData.deliveryAddress,
        customer_notes: orderData.customerNotes,
        status: 'pending',
        payment_status: 'pending'
      };

      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert(orderInsert)
        .select()
        .single();

      if (orderError) throw orderError;

      // Create order items
      const orderItems: OrderItemInsert[] = orderData.items.map(item => ({
        order_id: order.id,
        menu_item_id: item.menuItemId,
        quantity: item.quantity,
        unit_price: item.unitPrice,
        total_price: item.unitPrice * item.quantity,
        special_instructions: item.specialInstructions
      }));

      const { data: items, error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems)
        .select();

      if (itemsError) throw itemsError;

      // Update customer stats
      await supabase
        .from('customers')
        .update({
          total_orders: customer.total_orders + 1,
          total_spent: customer.total_spent + orderData.totalAmount,
          last_order_at: new Date().toISOString()
        })
        .eq('id', customer.id);

      return {
        ...order,
        order_items: items || [],
        customer: {
          name: customer.name,
          phone: customer.phone,
          email: customer.email
        }
      };
    } catch (error) {
      console.error('Error creating public order:', error);
      throw error;
    }
  }

  // Get order by order number (for tracking)
  static async getOrderByNumber(orderNumber: string): Promise<PublicOrderWithItems | null> {
    // Return mock data in demo mode
    if (isDemoMode()) {
      await mockApiDelay();
      return null; // No orders found in demo mode
    }

    try {
      const { data, error } = await supabase
        .from('orders')
        .select(`
          *,
          order_items (*),
          customers (name, phone, email)
        `)
        .eq('order_number', orderNumber)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }

      return data as PublicOrderWithItems;
    } catch (error) {
      console.error('Error getting order by number:', error);
      return null;
    }
  }

  // Get order status updates
  static async getOrderStatus(orderId: string): Promise<Order | null> {
    // Return mock data in demo mode
    if (isDemoMode()) {
      await mockApiDelay();
      return null; // No orders found in demo mode
    }

    try {
      const { data, error } = await supabase
        .from('orders')
        .select('id, status, estimated_delivery_time, delivered_at, created_at')
        .eq('id', orderId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error getting order status:', error);
      return null;
    }
  }
}